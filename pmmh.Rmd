---
title: "Particle Marginal Metropolis Hastings"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Bootstrap Filter in R (Stochastic Volatility)

### Prior Distribution
```{r}
prior_function <- function(n=1) rnorm(n, 0.0, sigma / sqrt((1 - alpha^2)))
```

### Transition Function
```{r}
transition_function <- function(x, n=1) rnorm(n, mean=alpha*x, sd=sigma)
```

### Emission Function and Likelihood Function
```{r}
emission_function <- function(x, beta) rnorm(n=1, mean=0, sd=beta*exp(x/2))
likelihood_function <- function(y, x, beta) dnorm(x=y, mean=0, sd=abs(beta*exp(x/2)))
```

### Data Generation
```{r}
set.seed(123)
alpha <- 0.91
sigma <- 1.0
beta  <- 0.5
tmax <- 100
data <- matrix(0, nrow=(tmax+1), ncol=2)
data[1, 1] <- prior_function(n=1)
data[1, 2] <- emission_function(data[1, 1], beta)
for (i in 2:(tmax+1)){
  data[i, 1] <- transition_function(data[i-1, 1])
  data[i, 2] <- emission_function(data[i, 1], beta)
}
plot(1:(tmax+1), data[, 1], type='l', main='Hidden State', xlab='t', ylab='x')
```


### Bootstrap Filter Settings
```{r}
N <- 500
y <- data[, 2]
```

### Bootstrap Filter Example Function
```{r}
bf <- function(beta, N=100){
  # Store the marginal approximation
  marginal <- 1.0
  # Initialize particles
  particles <- matrix(0, nrow=(tmax+1), ncol=N)
  particles[1, ] <- prior_function(n=N)
  # Main Bootstrap Filter Loop
  for (t in 2:(tmax+1)){
    # Sample from transition
    particles[t, ] <- transition_function(particles[t-1, ], N)
    # Compute importance weights
    weights <- likelihood_function(y[t], particles[t, ], beta)
    # Update the marginal approximation
    marginal <- marginal * mean(weights)
    # Normalize weights
    weights <- weights / sum(weights)
    # Resample
    resampled_ix <- sample(1:N, N, replace=TRUE, prob=weights)
    # Select particles based on resampled indices
    particles <- particles[, resampled_ix]
  }
  return(list(x=particles, w=weights, m=marginal))
}
```

```{r}
bf2 <- function(beta, N=100){
  # Store estimate of the marginal?
  marginal <- 1.0
  # Initialize particles
  particles <- matrix(0, nrow=(tmax+1), ncol=N)
  particles[1, ] <- prior_function(n=N)
  # Weights (uniform)
  weights <- rep(1/N, N)
  # Main Bootstrap Filter Loop
  for (t in 1:tmax){
    # Resample first
    particles <- particles[, sample(1:N, N, replace = TRUE, prob=weights)]
    # Propagate forward
    particles[t+1, ] <- transition_function(particles[t, ], N)
    # Compute importance weights
    weights <- likelihood_function(y[t+1], particles[t+1, ], beta)
    # Update the marginal estimation
    marginal <- marginal * mean(weights)
    # Normalize weights
    weights <- weights / sum(weights)
  }
  return(list(x=particles, w=weights, m=marginal))
} 
```


### Applying Bootstrap Filter
```{r}
out <- bf(beta=beta)
out2 <- bf2(beta=beta)
means <- apply(out$x, 1, mean)
means2 <- apply(out2$x, 1, mean)
plot(1:(tmax+1), data[, 1], type='l', main='Hidden State', xlab='t', ylab='x')
lines(1:(tmax+1), means, col='red')
lines(1:(tmax+1), means2, col='blue')
```

# Particle Marginal Metropolis-Hastings

```{r}
pmmh <- function(q, p, qeval, start=1.0, niter=100, N=100){
  ### INITIALIZATION
  # Run SMC targeting posterior
  out <- bf(start, N)
  # sample from the posterior
  ix <- sample(1:N, N, replace=T, prob=out$w)
  x  <- out$x[, ix]
  # Grab approximation to the marginal
  m <- out$m
  # set current param to the start
  theta <- start
  # compute uniform random numbers to accept
  u <- runif(niter)
  # store the samples
  samples <- rep(0, niter+1)
  samples[1] <- theta
  
  ### MAIN LOOP
  for (i in 1:niter){
    # Sample theta* ~ q(theta* | theta)
    theta_candidate <- q(theta)
    # Run SMC 
    out <- bf(theta_candidate, N)
    # Sample from it
    ix <- sample(1:N, N, replace=T, prob=out$w)
    x_candidate <- out$x[, ix]
    # Grab approximation to marginal
    m_candidate <- out$m
    # Compute acceptance ratio
    prob <- min(1, m_candidate*p(theta_candidate)*qeval(theta, theta_candidate) / m*p(theta)*qeval(theta_candidate, theta))
    # accept?
    if (u[i] <= prob){
      theta <- theta_candidate
      x <- x_candidate
      m <- m_candidate
    }
    samples[i+1] <- theta
  }
  # finally return the chain
  return(samples)
}
```

Run PMMH using the following settings

```{r}
q <- function(theta) rnorm(n=1, mean=theta, sd=0.2)
qeval <- function(theta_to_eval, theta_given) dnorm(x=theta_to_eval, mean=theta_given, sd=0.2)
p <- function(theta) dnorm(x=theta, mean=1.0, sd=0.2)
start <- 1.0
```


```{r}
samples <- pmmh(q=q, p=p, qeval=qeval, start=1.0, niter=5000, N=N)
```

```{r}
mean(samples)
```


```{r}
plot(samples, type='l')
```
















